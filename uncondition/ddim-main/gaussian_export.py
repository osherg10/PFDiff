"""Utilities for converting octree tokens into Gaussian splats.

The discrete diffusion model predicts BFS-ordered octree tokens
representing occupied voxels inside the unit cube. This module
reconstructs leaf cell centers/scales and writes them out as Gaussian
splat attributes (positions, scales, colors, opacities).
"""
from __future__ import annotations

import json
import os
from dataclasses import dataclass
from typing import Iterable, List, Optional, Sequence, Tuple

import numpy as np


@dataclass
class GaussianCloud:
    """Container holding Gaussian splat attributes."""

    positions: np.ndarray  # (N, 3)
    scales: np.ndarray  # (N, 3)
    colors: np.ndarray  # (N, 3)
    opacities: np.ndarray  # (N,)

    def __post_init__(self) -> None:
        self.positions = np.asarray(self.positions, dtype=np.float32)
        self.scales = np.asarray(self.scales, dtype=np.float32)
        self.colors = np.asarray(self.colors, dtype=np.float32)
        self.opacities = np.asarray(self.opacities, dtype=np.float32)


@dataclass
class OctreeNode:
    depth: int
    bounds_min: np.ndarray
    bounds_max: np.ndarray


def _child_bounds(bounds_min: np.ndarray, bounds_max: np.ndarray, child_idx: int) -> Tuple[np.ndarray, np.ndarray]:
    offset = np.array(
        [(child_idx >> 2) & 1, (child_idx >> 1) & 1, child_idx & 1], dtype=np.float32
    )
    child_min = bounds_min + (bounds_max - bounds_min) * 0.5 * offset
    child_max = child_min + (bounds_max - bounds_min) * 0.5
    return child_min, child_max


def decode_octree_tokens(
    tokens: Sequence[int],
    *,
    max_depth: int,
    mask: Optional[Sequence[bool]] = None,
    bounds_min: Optional[Sequence[float]] = None,
    bounds_max: Optional[Sequence[float]] = None,
) -> Tuple[np.ndarray, np.ndarray]:
    """Convert BFS-ordered octree tokens into leaf centers and scales.

    Parameters
    ----------
    tokens:
        Iterable of integer tokens representing occupancy masks.
    max_depth:
        Maximum subdivision depth used when the tokens were generated.
    mask:
        Optional boolean mask marking valid token positions (to ignore
        padded entries from fixed-length arrays).
    bounds_min / bounds_max:
        3-element sequences defining the root cube bounds. Defaults to
        the unit cube ``[0, 1]^3``.
    """

    tokens_np = np.asarray(tokens).astype(np.int64)
    if mask is not None:
        mask = np.asarray(mask).astype(bool)
    bounds_min_np = (
        np.zeros(3, dtype=np.float32)
        if bounds_min is None
        else np.asarray(bounds_min, dtype=np.float32)
    )
    bounds_max_np = (
        np.ones(3, dtype=np.float32)
        if bounds_max is None
        else np.asarray(bounds_max, dtype=np.float32)
    )

    queue: List[OctreeNode] = [OctreeNode(0, bounds_min_np, bounds_max_np)]
    positions: List[np.ndarray] = []
    scales: List[np.ndarray] = []

    idx = 0
    while queue and idx < tokens_np.shape[0]:
        node = queue.pop(0)
        if mask is not None and (idx >= mask.shape[0] or not mask[idx]):
            break

        token = int(tokens_np[idx])
        idx += 1

        if token == 0:
            continue

        is_leaf = node.depth >= max_depth
        if is_leaf:
            center = (node.bounds_min + node.bounds_max) * 0.5
            extent = (node.bounds_max - node.bounds_min) * 0.5
            positions.append(center)
            scales.append(extent)
            continue

        for child_idx in range(8):
            if token & (1 << child_idx):
                child_min, child_max = _child_bounds(node.bounds_min, node.bounds_max, child_idx)
                queue.append(
                    OctreeNode(node.depth + 1, child_min, child_max)
                )

    if not positions:
        return np.empty((0, 3), dtype=np.float32), np.empty((0, 3), dtype=np.float32)

    return np.stack(positions, axis=0), np.stack(scales, axis=0)


def tokens_to_gaussians(
    tokens: Sequence[int],
    *,
    max_depth: int,
    mask: Optional[Sequence[bool]] = None,
    color: Sequence[float] = (1.0, 1.0, 1.0),
    opacity: float = 1.0,
) -> GaussianCloud:
    """Decode tokens and attach Gaussian attributes."""

    positions, scales = decode_octree_tokens(tokens, max_depth=max_depth, mask=mask)
    colors = np.broadcast_to(np.asarray(color, dtype=np.float32), (positions.shape[0], 3))
    opacities = np.full((positions.shape[0],), float(opacity), dtype=np.float32)
    return GaussianCloud(positions=positions, scales=scales, colors=colors, opacities=opacities)


def save_gaussians_ply(path: str, cloud: GaussianCloud) -> None:
    """Write Gaussian splats to a PLY file with per-vertex attributes."""

    header = """ply
format ascii 1.0
comment Generated by gaussian_export.py
comment Each vertex encodes a Gaussian splat center, scale, RGB color, and opacity
element vertex {num_vertices}
property float x
property float y
property float z
property float scale_x
property float scale_y
property float scale_z
property uchar red
property uchar green
property uchar blue
property float opacity
end_header
"""

    colors_uint8 = np.clip(cloud.colors * 255.0, 0, 255).astype(np.uint8)
    with open(path, "w", encoding="utf-8") as handle:
        handle.write(header.format(num_vertices=cloud.positions.shape[0]))
        for pos, scale, color, alpha in zip(
            cloud.positions, cloud.scales, colors_uint8, cloud.opacities
        ):
            handle.write(
                f"{pos[0]} {pos[1]} {pos[2]} "
                f"{scale[0]} {scale[1]} {scale[2]} "
                f"{int(color[0])} {int(color[1])} {int(color[2])} "
                f"{alpha}\n"
            )


def save_gaussians_json(path: str, cloud: GaussianCloud) -> None:
    """Write Gaussian splats as a JSON structure."""

    payload = {
        "positions": cloud.positions.tolist(),
        "scales": cloud.scales.tolist(),
        "colors": cloud.colors.tolist(),
        "opacities": cloud.opacities.tolist(),
    }
    with open(path, "w", encoding="utf-8") as handle:
        json.dump(payload, handle)


def export_tokens_file(
    input_path: str,
    output_path: str,
    *,
    max_depth: int,
    output_format: str = "ply",
    color: Sequence[float] = (1.0, 1.0, 1.0),
    opacity: float = 1.0,
) -> str:
    """Convert a single token npz/npy file into Gaussian splats."""

    data = np.load(input_path, allow_pickle=False)
    tokens = data["tokens"] if "tokens" in data else data
    mask = data["mask"] if "mask" in data else None
    cloud = tokens_to_gaussians(tokens, max_depth=max_depth, mask=mask, color=color, opacity=opacity)

    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    fmt = output_format.lower()
    if fmt == "ply":
        save_gaussians_ply(output_path, cloud)
    elif fmt == "json":
        save_gaussians_json(output_path, cloud)
    else:
        raise ValueError(f"Unsupported export format: {output_format}")
    return output_path


def export_folder(
    input_folder: str,
    *,
    max_depth: int,
    output_format: str = "ply",
    output_folder: Optional[str] = None,
    color: Sequence[float] = (1.0, 1.0, 1.0),
    opacity: float = 1.0,
) -> List[str]:
    """Batch-convert all token files in a folder."""

    outputs: List[str] = []
    output_root = output_folder or input_folder
    os.makedirs(output_root, exist_ok=True)

    for name in sorted(os.listdir(input_folder)):
        if not (name.endswith(".npz") or name.endswith(".npy")):
            continue
        in_path = os.path.join(input_folder, name)
        base, _ = os.path.splitext(name)
        out_path = os.path.join(output_root, f"{base}.{output_format}")
        outputs.append(
            export_tokens_file(
                in_path,
                out_path,
                max_depth=max_depth,
                output_format=output_format,
                color=color,
                opacity=opacity,
            )
        )
    return outputs


__all__ = [
    "GaussianCloud",
    "decode_octree_tokens",
    "tokens_to_gaussians",
    "save_gaussians_ply",
    "save_gaussians_json",
    "export_tokens_file",
    "export_folder",
]
